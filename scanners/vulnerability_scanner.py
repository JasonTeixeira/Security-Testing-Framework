"""
Basic Vulnerability Scanner
Tests for common security issues in web applications
"""

import requests
from urllib.parse import urljoin
from typing import List, Dict
from loguru import logger
import time


class VulnerabilityScanner:
    """
    Scans web applications for common vulnerabilities.
    
    Tests for:
    - SQL Injection
    - XSS (Cross-Site Scripting)
    - Insecure Headers
    - Open Redirects
    """
    
    def __init__(self, target_url: str, timeout: int = 10):
        """
        Initialize scanner with target URL.
        
        Args:
            target_url: Base URL to scan
            timeout: Request timeout in seconds
        """
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.vulnerabilities = []
        
    def scan_all(self) -> List[Dict]:
        """
        Run all vulnerability scans.
        
        Returns:
            List of found vulnerabilities
        """
        logger.info(f"Starting security scan on {self.target_url}")
        
        self.test_sql_injection()
        self.test_xss()
        self.test_security_headers()
        self.test_open_redirect()
        
        logger.info(f"Scan complete. Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities
    
    def test_sql_injection(self):
        """Test for SQL injection vulnerabilities."""
        logger.info("Testing for SQL injection...")
        
        # Common SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "1' OR '1' = '1",
        ]
        
        test_params = ['id', 'user', 'search', 'q']
        
        for param in test_params:
            for payload in payloads:
                url = f"{self.target_url}?{param}={payload}"
                try:
                    response = requests.get(url, timeout=self.timeout)
                    
                    # Check for SQL error messages
                    sql_errors = [
                        'SQL syntax',
                        'mysql_fetch',
                        'ORA-',
                        'PostgreSQL',
                        'Microsoft SQL',
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            self._add_vulnerability(
                                'SQL Injection',
                                'HIGH',
                                url,
                                f"Possible SQL injection detected with payload: {payload}"
                            )
                            logger.warning(f"SQL injection found: {url}")
                            break
                            
                except Exception as e:
                    logger.debug(f"Error testing {url}: {e}")
                
                time.sleep(0.5)  # Be polite
    
    def test_xss(self):
        """Test for Cross-Site Scripting vulnerabilities."""
        logger.info("Testing for XSS...")
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
        ]
        
        test_params = ['q', 'search', 'input', 'name']
        
        for param in test_params:
            for payload in payloads:
                url = f"{self.target_url}?{param}={payload}"
                try:
                    response = requests.get(url, timeout=self.timeout)
                    
                    # Check if payload is reflected unescaped
                    if payload in response.text:
                        self._add_vulnerability(
                            'Cross-Site Scripting (XSS)',
                            'HIGH',
                            url,
                            f"Unescaped input reflected: {payload}"
                        )
                        logger.warning(f"XSS vulnerability found: {url}")
                        
                except Exception as e:
                    logger.debug(f"Error testing {url}: {e}")
                
                time.sleep(0.5)
    
    def test_security_headers(self):
        """Check for missing security headers."""
        logger.info("Checking security headers...")
        
        try:
            response = requests.get(self.target_url, timeout=self.timeout)
            headers = response.headers
            
            # Important security headers
            required_headers = {
                'X-Content-Type-Options': 'nosniff',
                'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
                'Content-Security-Policy': None,  # Just check if present
                'Strict-Transport-Security': None,
                'X-XSS-Protection': '1; mode=block',
            }
            
            for header, expected in required_headers.items():
                if header not in headers:
                    self._add_vulnerability(
                        'Missing Security Header',
                        'MEDIUM',
                        self.target_url,
                        f"Missing header: {header}"
                    )
                    logger.info(f"Missing header: {header}")
                    
        except Exception as e:
            logger.error(f"Error checking headers: {e}")
    
    def test_open_redirect(self):
        """Test for open redirect vulnerabilities."""
        logger.info("Testing for open redirects...")
        
        redirect_params = ['url', 'redirect', 'next', 'return', 'returnUrl']
        test_urls = ['http://evil.com', 'https://attacker.com']
        
        for param in redirect_params:
            for test_url in test_urls:
                url = f"{self.target_url}?{param}={test_url}"
                try:
                    response = requests.get(
                        url, 
                        timeout=self.timeout,
                        allow_redirects=False
                    )
                    
                    # Check if redirects to external URL
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        if test_url in location:
                            self._add_vulnerability(
                                'Open Redirect',
                                'MEDIUM',
                                url,
                                f"Redirects to external URL: {location}"
                            )
                            logger.warning(f"Open redirect found: {url}")
                            
                except Exception as e:
                    logger.debug(f"Error testing {url}: {e}")
                
                time.sleep(0.5)
    
    def _add_vulnerability(self, vuln_type: str, severity: str, url: str, description: str):
        """Add vulnerability to results."""
        self.vulnerabilities.append({
            'type': vuln_type,
            'severity': severity,
            'url': url,
            'description': description,
        })
    
    def get_summary(self) -> Dict:
        """Get summary of findings."""
        severities = {'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        
        for vuln in self.vulnerabilities:
            severities[vuln['severity']] += 1
        
        return {
            'total': len(self.vulnerabilities),
            'high': severities['HIGH'],
            'medium': severities['MEDIUM'],
            'low': severities['LOW'],
        }
